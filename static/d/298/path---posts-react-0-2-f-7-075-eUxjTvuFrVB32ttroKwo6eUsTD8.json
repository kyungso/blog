{"data":{"site":{"siteMetadata":{"author":{"name":"Kingso","contacts":{"twitter":"#"}},"disqusShortname":"kingsoblog","subtitle":"Kingso's blog","title":"Kingso's blog","url":"https://kingso.netlify.com"}},"markdownRemark":{"id":"774bdbcc-c033-585a-adf0-8ac37445a6c0","html":"<br>\n<h3 id=\"라이브러리프레임워크는-왜-필요한가\"><a href=\"#%EB%9D%BC%EC%9D%B4%EB%B8%8C%EB%9F%AC%EB%A6%AC%ED%94%84%EB%A0%88%EC%9E%84%EC%9B%8C%ED%81%AC%EB%8A%94-%EC%99%9C-%ED%95%84%EC%9A%94%ED%95%9C%EA%B0%80\" aria-label=\"라이브러리프레임워크는 왜 필요한가 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>라이브러리/프레임워크는 왜 필요한가?</h3>\n<p>웹 사이트를 만들기 위해선, 굳이 라이브러리나 프레임워크 없이도 구조를 담당하는 HTML, 표현을 담당하는 CSS, 사용자의 행동흐름에 따라서 동작하게끔 하는 Javascript로 만들 수 있습니다.</p>\n<p>하지만 요즘의 웹은 옛날처럼 정적으로 웹 페이지가 아니라, 웹 어플리케이션로 사용자와의 상호작용이 매우 자유롭게 이어지고 있습니다.</p>\n<p>Javascipt를 예제로 들어보면,</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">document.querySelector(&quot;div&quot;);</code></pre></div>\n<p>이것을 jQuery로 나타내면,</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">$(&#39;div&#39;)</code></pre></div>\n<p>이런식으로 DOM을 가져옵니다.</p>\n<p>하지만, 프로젝트의 규모가 커지고, 정말 다양한 사용자와의 인터렉션을 제공하게 된다면, 그 많은 DOM 요소들을 직접 관리하고, 코드 작성하는 것은 정말 힘든 일입니다.</p>\n<p>즉, 웹 개발을 할 때, <strong>귀찮은 DOM 관리</strong> 나, <strong>상태 값 업데이트 관리를 최소화</strong> 하고, 기능 개발, 사용자 인터페이스(UI)를 구현하는 것에 집중할 수 있도록 하기 위해 여러 라이브러리나 프레임워크가 등장했습니다.</p>\n<br>\n<h2 id=\"react-소개\"><a href=\"#react-%EC%86%8C%EA%B0%9C\" aria-label=\"react 소개 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>React 소개</h2>\n<p>리액트의 매뉴얼을 보면 다음과 같은 내용이 있습니다.</p>\n<blockquote>\n<p>We built React to solve one problem: building large applications with data that changes over time.\n번역: 우리는 지속해서 데이터가 변화하는 대규모 애플리케이션을 구축하기 위해 React를 만들었습니다</p>\n</blockquote>\n<p><strong>“변화(Mutation)”</strong> 는 복잡한 작업입니다. 특정 이벤트가 발생했을 때, 모델에 변화를 일으키고, 변화를 일으킴에 따라 어떤 DOM을 가져와서 어떠한 방식으로 뷰를 업데이트 해줄 지 로직을 정해줘야 합니다. 페이스북은 아래와 같이 이러한 발상을 했다고 합니다.</p>\n<blockquote>\n<p>Mutation을 하지 말자. 그 대신에, 데이터가 바뀌면 그냥 뷰를 날려버리고 새로 만들어버리면 어떨까?</p>\n</blockquote>\n<p>그렇게 하면 정말 간단하겠지만, DOM 기반으로 하는 웹은 계속 새로운 뷰를 만들어버리면 성능적으로 엄청 문제가 생길 것입니다.</p>\n<p>그래서 나오게된 것이 <strong>“Virtual DOM”</strong> 입니다.</p>\n<br>\n<h2 id=\"virtual-dom\"><a href=\"#virtual-dom\" aria-label=\"virtual dom permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Virtual DOM</h2>\n<p>Virtual DOM은 말 그대로 가상 DOM 입니다. 변화가 일어나면, 실제로 브라우저의 DOM에 적용하는 것이 아니라, 자바스크립트로 이뤄진 가상 DOM에 한 번 렌더링을 하고, 기존의 DOM과 비교를 한 다음에 정말 변화가 필요한 곳에만 업데이트를 해주는 것입니다.</p>\n<p>Virtual DOM 을 사용함으로서, 데이터가 바뀌었을 때 더 이상 어떻게 업데이트 할 지 로직을 고려하는게 아니라, 그냥 일단 바뀐 데이터로 일단 그려놓고 비교를 한다음에, 바뀐 부분만 찾아서 바꿔주는 것입니다.</p>\n<p>Virtual DOM을 쉽게 이해할 수 있는 velopert님의 동영상이 있습니다.</p>\n<ul>\n<li>React and the Virtual DOM : (<a href=\"https://www.youtube.com/watch?v=muc2ZF0QIO4\">https://www.youtube.com/watch?v=muc2ZF0QIO4</a>)</li>\n</ul>\n<br>\n<h3 id=\"왜-virtual-dom-인가\"><a href=\"#%EC%99%9C-virtual-dom-%EC%9D%B8%EA%B0%80\" aria-label=\"왜 virtual dom 인가 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>왜 Virtual DOM 인가?</h3>\n<p>DOM을 조작했을 때,</p>\n<blockquote>\n<p>DOM 변화 —> Render Tree 재생성 (모든 요소들의 스타일이 다시 계산) —> 레이아웃 계산 —> 페인팅</p>\n</blockquote>\n<p>복잡한 SPA(Single Page Application) 에서는 DOM 조작이 많이 발생한다. 그 뜻은 그 변화를 적용하기 위해 브라우저가 많이 연산을 해야한단 소리고, 전체적인 프로세스를 비효율적으로 만듭니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">예를 들어,\n\n30개의 노드를 하나 하나 수정하면,\n30번의 (잠재적인) 레이아웃 재계산과 30번의 (잠재적인) 리렌더링을 초래합니다.\n\n그러나, Virtual DOM을 사용하게 되면,\n모든 변화를 하나로 묶어서 딱 한 번 실행합니다.\n그렇게 되면, 1번의 레이아웃 재계산과 1번의 리렌더링을 합니다.</code></pre></div>\n<p>따라서, 뷰에 변화가 있다면, 그 변화는 실제 DOM에 적용되기 전에 가상의 DOM에 먼저 적용시키고 그 최종적인 결과를 실제 DOM으로 전달해줍니다. 이로써, 브라우저 내에서 발생하는 연산의 양을 줄이면서 성능이 개선됩니다.</p>\n<p>사실 이 과정은 Virtual DOM 없이 변화가 있을 때, 그 변화를 묶어서 DOM fragment에 적용한 다음에 기존 DOM에 적용하면 된다고 합니다.</p>\n<p>그러면, <strong>Virtual DOM이 해결하려고 하는 것은 무엇이냐?</strong></p>\n<ul>\n<li>\n<p>위에 말한 DOM fragment를 관리하는 과정을 수동으로 작업할 필요 없이, 자동화하고 추상화하는 것이다.</p>\n</li>\n<li>\n<p>기존 값 중 어떤 것이 바뀌었고, 어떤 것이 바뀌지 않았는지 계속 파악하기 쉽지 않기 때문에, 이것을 알아내어 해결해줍니다.</p>\n</li>\n<li>\n<p>DOM 관리를 함으로써, 컴포넌트가 DOM 조작 요청을 할 떄, 다른 컴포넌트들과 상호작용을 하지 않아도 되고, 특정 DOM을 조작할 것 이라던지, 이미 조작했다던지에 대한 정보를 공유할 필요가 없다. 즉, 각 변화들의 동기화 작업을 거치지 않으면서도 모든 작업을 하나로 묶어줄 수 있다.</p>\n</li>\n</ul>\n<br>\n<p><strong>참고 - <a href=\"https://velopert.com/3236\">https://velopert.com/3236</a></strong></p>\n<br>\n<h3 id=\"그-외의-react와-관련된-정보\"><a href=\"#%EA%B7%B8-%EC%99%B8%EC%9D%98-react%EC%99%80-%EA%B4%80%EB%A0%A8%EB%90%9C-%EC%A0%95%EB%B3%B4\" aria-label=\"그 외의 react와 관련된 정보 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>그 외의 React와 관련된 정보</h3>\n<p>리액트는 정말 자유도가 높은 라이브러리입니다. 예를들어서 라우터, 혹은 상태관리 같은 기능들이 리액트 자체에 내장되어있지도 않고, 공식적인 라이브러리도 없습니다. 하지만 써드파티 라이브러리가 존재합니다.</p>\n<br>\n<ul>\n<li>라우터쪽을 보자면, React-router, 그리고 Next.js, After.js 같은 라이브러리들이 있습니다.</li>\n</ul>\n<br>\n<ul>\n<li>상태 관리 라이브러리만해도, Redux, MobX, fr(e)actal 같은 라이브러리들이 있습니다.</li>\n</ul>\n<br>\n<p>그리고 리액트 컴포넌트 스타일링을 할 때도 한가지 정해진 방식이 있는게 아니라 수많은 방식으로 할 수 있습니다.</p>\n<p>이에 따른 장점은, 여러분들이 가장 맘에드는것을 사용하거나 심지어 직접 만들어서 사용 할 수도 있다는 점이고, 단점은 여러가지를 시도해볼 필요가 있고, 어느 것 하나를 선택하는 게 어려울수 있다는 점 입니다.</p>\n<br>\n<p><strong>참고 - <a href=\"https://velopert.com/3621\">https://velopert.com/3621</a></strong></p>","fields":{"slug":"/posts/React0/","tagSlugs":["/tag/frontend/","/tag/react/"]},"frontmatter":{"date":"2019-07-16T14:00:00.169Z","description":"리액트는 무엇인가","tags":["Frontend","React"],"title":"React - 00"}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/posts/React0/"}}